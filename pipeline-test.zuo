#lang jiu

(define (1+ n)
  (+ 1 n))
(define (inspect x)
  (display "inspect: ")
  (displayln x)
  x)
(define (findf pred lst)
  (cond
    [(null? lst) #f]
    [(pred (car lst)) (car lst)]
    [else (findf pred (cdr lst))]))
(define (even? n)
  (= (modulo n 2) 0))
(define (sqr n)
  (* n n))
(define (filter-not pred lst)
  (cond
    [(null? lst) '()]
    [(pred (car lst)) (filter-not pred (cdr lst))]
    [else (cons (car lst) (filter-not pred (cdr lst)))]))
(define (zero? n)
  (= n 0))

(~> 5
  (* 2)
  (+ 1)
  inspect ; inspect: 11
  (remainder 98 _)) ; 10

(~> '(1 2 3)
    (map 1+ _)
    cadr
    (* 2)) ; 6

(map (lambda~> 1+ (* 2))
     (list 1 2 3 4 5)) ; (list 4 6 8 10 12)

((lambda~>* cadr sqr) 1 2 3) ; 4

(and~> '(1 3 5)
       (map 1+ _)
       (findf even? _)) ; 2

(and~> '(2 4 6)
       (map 1+ _)
       (findf even? _)) ; #f

(~> (list 1 2 3 4 5 6 7 8)
    (tee~> displayln) ; (1 2 3 4 5 6 7 8)
    (map sqr _)
    (tee~> displayln) ; (1 4 9 16 25 36 49 64)
    (filter-not (lambda~> (remainder 4) zero?) _)
    (tee~> displayln) ; (1 9 25 49)
    (apply + _)) ; 84

(when~> 5 (> 5 3) 1+ (* 2)) ; => 12
(when~> 5 (< 5 3) 1+ (* 2)) ; => 5

(unless~> 5 (> 5 3) 1+ (* 2)) ; => 5
(unless~> 5 (< 5 3) 1+ (* 2)) ; => 12

(define (f n)
  (~> 11
      (cond~>
        [(= n 1) 1+ (* 2)]
        [(= n 2) 1+ (+ 2)]
        [else    -])))

(f 1) ; => 24
(f 2) ; => 14
(f 3) ; => -11

(~> (displayln str)
    (let ([str "amazing"]) _)) ; print: amazing
(~> ([str "amazing"])
    (let (displayln str))) ; print: amazing
(~> ([ans 42])
    (let ans)) ; 42
